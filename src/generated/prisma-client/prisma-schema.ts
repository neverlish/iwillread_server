// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBook {
  count: Int!
}

type AggregateBookAuthor {
  count: Int!
}

type AggregateBookCategory {
  count: Int!
}

type AggregateBookHashtag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserBookRead {
  count: Int!
}

type AggregateUserBookWant {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Book {
  id: ID!
  name: String!
  datePublished: DateTime!
  description: String!
  dateCreated: DateTime!
  hashtags(where: BookHashtagWhereInput, orderBy: BookHashtagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookHashtag!]
  author: BookAuthor!
  coverImage: String!
  images: [String!]!
}

type BookAuthor {
  id: ID!
  name: String!
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book!]
}

type BookAuthorConnection {
  pageInfo: PageInfo!
  edges: [BookAuthorEdge]!
  aggregate: AggregateBookAuthor!
}

input BookAuthorCreateInput {
  id: ID
  name: String!
  books: BookCreateManyWithoutAuthorInput
}

input BookAuthorCreateOneWithoutBooksInput {
  create: BookAuthorCreateWithoutBooksInput
  connect: BookAuthorWhereUniqueInput
}

input BookAuthorCreateWithoutBooksInput {
  id: ID
  name: String!
}

type BookAuthorEdge {
  node: BookAuthor!
  cursor: String!
}

enum BookAuthorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type BookAuthorPreviousValues {
  id: ID!
  name: String!
}

type BookAuthorSubscriptionPayload {
  mutation: MutationType!
  node: BookAuthor
  updatedFields: [String!]
  previousValues: BookAuthorPreviousValues
}

input BookAuthorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookAuthorWhereInput
  AND: [BookAuthorSubscriptionWhereInput!]
  OR: [BookAuthorSubscriptionWhereInput!]
  NOT: [BookAuthorSubscriptionWhereInput!]
}

input BookAuthorUpdateInput {
  name: String
  books: BookUpdateManyWithoutAuthorInput
}

input BookAuthorUpdateManyMutationInput {
  name: String
}

input BookAuthorUpdateOneRequiredWithoutBooksInput {
  create: BookAuthorCreateWithoutBooksInput
  update: BookAuthorUpdateWithoutBooksDataInput
  upsert: BookAuthorUpsertWithoutBooksInput
  connect: BookAuthorWhereUniqueInput
}

input BookAuthorUpdateWithoutBooksDataInput {
  name: String
}

input BookAuthorUpsertWithoutBooksInput {
  update: BookAuthorUpdateWithoutBooksDataInput!
  create: BookAuthorCreateWithoutBooksInput!
}

input BookAuthorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  books_every: BookWhereInput
  books_some: BookWhereInput
  books_none: BookWhereInput
  AND: [BookAuthorWhereInput!]
  OR: [BookAuthorWhereInput!]
  NOT: [BookAuthorWhereInput!]
}

input BookAuthorWhereUniqueInput {
  id: ID
}

type BookCategory {
  id: ID!
  name: String!
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book!]
}

type BookCategoryConnection {
  pageInfo: PageInfo!
  edges: [BookCategoryEdge]!
  aggregate: AggregateBookCategory!
}

input BookCategoryCreateInput {
  id: ID
  name: String!
  books: BookCreateManyInput
}

type BookCategoryEdge {
  node: BookCategory!
  cursor: String!
}

enum BookCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type BookCategoryPreviousValues {
  id: ID!
  name: String!
}

type BookCategorySubscriptionPayload {
  mutation: MutationType!
  node: BookCategory
  updatedFields: [String!]
  previousValues: BookCategoryPreviousValues
}

input BookCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookCategoryWhereInput
  AND: [BookCategorySubscriptionWhereInput!]
  OR: [BookCategorySubscriptionWhereInput!]
  NOT: [BookCategorySubscriptionWhereInput!]
}

input BookCategoryUpdateInput {
  name: String
  books: BookUpdateManyInput
}

input BookCategoryUpdateManyMutationInput {
  name: String
}

input BookCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  books_every: BookWhereInput
  books_some: BookWhereInput
  books_none: BookWhereInput
  AND: [BookCategoryWhereInput!]
  OR: [BookCategoryWhereInput!]
  NOT: [BookCategoryWhereInput!]
}

input BookCategoryWhereUniqueInput {
  id: ID
  name: String
}

type BookConnection {
  pageInfo: PageInfo!
  edges: [BookEdge]!
  aggregate: AggregateBook!
}

input BookCreateimagesInput {
  set: [String!]
}

input BookCreateInput {
  id: ID
  name: String!
  datePublished: DateTime!
  description: String!
  hashtags: BookHashtagCreateManyWithoutBooksInput
  author: BookAuthorCreateOneWithoutBooksInput!
  coverImage: String!
  images: BookCreateimagesInput
}

input BookCreateManyInput {
  create: [BookCreateInput!]
  connect: [BookWhereUniqueInput!]
}

input BookCreateManyWithoutAuthorInput {
  create: [BookCreateWithoutAuthorInput!]
  connect: [BookWhereUniqueInput!]
}

input BookCreateManyWithoutHashtagsInput {
  create: [BookCreateWithoutHashtagsInput!]
  connect: [BookWhereUniqueInput!]
}

input BookCreateOneInput {
  create: BookCreateInput
  connect: BookWhereUniqueInput
}

input BookCreateWithoutAuthorInput {
  id: ID
  name: String!
  datePublished: DateTime!
  description: String!
  hashtags: BookHashtagCreateManyWithoutBooksInput
  coverImage: String!
  images: BookCreateimagesInput
}

input BookCreateWithoutHashtagsInput {
  id: ID
  name: String!
  datePublished: DateTime!
  description: String!
  author: BookAuthorCreateOneWithoutBooksInput!
  coverImage: String!
  images: BookCreateimagesInput
}

type BookEdge {
  node: Book!
  cursor: String!
}

type BookHashtag {
  id: ID!
  name: String!
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book!]
}

type BookHashtagConnection {
  pageInfo: PageInfo!
  edges: [BookHashtagEdge]!
  aggregate: AggregateBookHashtag!
}

input BookHashtagCreateInput {
  id: ID
  name: String!
  books: BookCreateManyWithoutHashtagsInput
}

input BookHashtagCreateManyWithoutBooksInput {
  create: [BookHashtagCreateWithoutBooksInput!]
  connect: [BookHashtagWhereUniqueInput!]
}

input BookHashtagCreateWithoutBooksInput {
  id: ID
  name: String!
}

type BookHashtagEdge {
  node: BookHashtag!
  cursor: String!
}

enum BookHashtagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type BookHashtagPreviousValues {
  id: ID!
  name: String!
}

input BookHashtagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [BookHashtagScalarWhereInput!]
  OR: [BookHashtagScalarWhereInput!]
  NOT: [BookHashtagScalarWhereInput!]
}

type BookHashtagSubscriptionPayload {
  mutation: MutationType!
  node: BookHashtag
  updatedFields: [String!]
  previousValues: BookHashtagPreviousValues
}

input BookHashtagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookHashtagWhereInput
  AND: [BookHashtagSubscriptionWhereInput!]
  OR: [BookHashtagSubscriptionWhereInput!]
  NOT: [BookHashtagSubscriptionWhereInput!]
}

input BookHashtagUpdateInput {
  name: String
  books: BookUpdateManyWithoutHashtagsInput
}

input BookHashtagUpdateManyDataInput {
  name: String
}

input BookHashtagUpdateManyMutationInput {
  name: String
}

input BookHashtagUpdateManyWithoutBooksInput {
  create: [BookHashtagCreateWithoutBooksInput!]
  delete: [BookHashtagWhereUniqueInput!]
  connect: [BookHashtagWhereUniqueInput!]
  set: [BookHashtagWhereUniqueInput!]
  disconnect: [BookHashtagWhereUniqueInput!]
  update: [BookHashtagUpdateWithWhereUniqueWithoutBooksInput!]
  upsert: [BookHashtagUpsertWithWhereUniqueWithoutBooksInput!]
  deleteMany: [BookHashtagScalarWhereInput!]
  updateMany: [BookHashtagUpdateManyWithWhereNestedInput!]
}

input BookHashtagUpdateManyWithWhereNestedInput {
  where: BookHashtagScalarWhereInput!
  data: BookHashtagUpdateManyDataInput!
}

input BookHashtagUpdateWithoutBooksDataInput {
  name: String
}

input BookHashtagUpdateWithWhereUniqueWithoutBooksInput {
  where: BookHashtagWhereUniqueInput!
  data: BookHashtagUpdateWithoutBooksDataInput!
}

input BookHashtagUpsertWithWhereUniqueWithoutBooksInput {
  where: BookHashtagWhereUniqueInput!
  update: BookHashtagUpdateWithoutBooksDataInput!
  create: BookHashtagCreateWithoutBooksInput!
}

input BookHashtagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  books_every: BookWhereInput
  books_some: BookWhereInput
  books_none: BookWhereInput
  AND: [BookHashtagWhereInput!]
  OR: [BookHashtagWhereInput!]
  NOT: [BookHashtagWhereInput!]
}

input BookHashtagWhereUniqueInput {
  id: ID
  name: String
}

enum BookOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  datePublished_ASC
  datePublished_DESC
  description_ASC
  description_DESC
  dateCreated_ASC
  dateCreated_DESC
  coverImage_ASC
  coverImage_DESC
}

type BookPreviousValues {
  id: ID!
  name: String!
  datePublished: DateTime!
  description: String!
  dateCreated: DateTime!
  coverImage: String!
  images: [String!]!
}

input BookScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  datePublished: DateTime
  datePublished_not: DateTime
  datePublished_in: [DateTime!]
  datePublished_not_in: [DateTime!]
  datePublished_lt: DateTime
  datePublished_lte: DateTime
  datePublished_gt: DateTime
  datePublished_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  coverImage: String
  coverImage_not: String
  coverImage_in: [String!]
  coverImage_not_in: [String!]
  coverImage_lt: String
  coverImage_lte: String
  coverImage_gt: String
  coverImage_gte: String
  coverImage_contains: String
  coverImage_not_contains: String
  coverImage_starts_with: String
  coverImage_not_starts_with: String
  coverImage_ends_with: String
  coverImage_not_ends_with: String
  AND: [BookScalarWhereInput!]
  OR: [BookScalarWhereInput!]
  NOT: [BookScalarWhereInput!]
}

type BookSubscriptionPayload {
  mutation: MutationType!
  node: Book
  updatedFields: [String!]
  previousValues: BookPreviousValues
}

input BookSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookWhereInput
  AND: [BookSubscriptionWhereInput!]
  OR: [BookSubscriptionWhereInput!]
  NOT: [BookSubscriptionWhereInput!]
}

input BookUpdateDataInput {
  name: String
  datePublished: DateTime
  description: String
  hashtags: BookHashtagUpdateManyWithoutBooksInput
  author: BookAuthorUpdateOneRequiredWithoutBooksInput
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateimagesInput {
  set: [String!]
}

input BookUpdateInput {
  name: String
  datePublished: DateTime
  description: String
  hashtags: BookHashtagUpdateManyWithoutBooksInput
  author: BookAuthorUpdateOneRequiredWithoutBooksInput
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateManyDataInput {
  name: String
  datePublished: DateTime
  description: String
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateManyInput {
  create: [BookCreateInput!]
  update: [BookUpdateWithWhereUniqueNestedInput!]
  upsert: [BookUpsertWithWhereUniqueNestedInput!]
  delete: [BookWhereUniqueInput!]
  connect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  disconnect: [BookWhereUniqueInput!]
  deleteMany: [BookScalarWhereInput!]
  updateMany: [BookUpdateManyWithWhereNestedInput!]
}

input BookUpdateManyMutationInput {
  name: String
  datePublished: DateTime
  description: String
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateManyWithoutAuthorInput {
  create: [BookCreateWithoutAuthorInput!]
  delete: [BookWhereUniqueInput!]
  connect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  disconnect: [BookWhereUniqueInput!]
  update: [BookUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [BookUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [BookScalarWhereInput!]
  updateMany: [BookUpdateManyWithWhereNestedInput!]
}

input BookUpdateManyWithoutHashtagsInput {
  create: [BookCreateWithoutHashtagsInput!]
  delete: [BookWhereUniqueInput!]
  connect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  disconnect: [BookWhereUniqueInput!]
  update: [BookUpdateWithWhereUniqueWithoutHashtagsInput!]
  upsert: [BookUpsertWithWhereUniqueWithoutHashtagsInput!]
  deleteMany: [BookScalarWhereInput!]
  updateMany: [BookUpdateManyWithWhereNestedInput!]
}

input BookUpdateManyWithWhereNestedInput {
  where: BookScalarWhereInput!
  data: BookUpdateManyDataInput!
}

input BookUpdateOneRequiredInput {
  create: BookCreateInput
  update: BookUpdateDataInput
  upsert: BookUpsertNestedInput
  connect: BookWhereUniqueInput
}

input BookUpdateWithoutAuthorDataInput {
  name: String
  datePublished: DateTime
  description: String
  hashtags: BookHashtagUpdateManyWithoutBooksInput
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateWithoutHashtagsDataInput {
  name: String
  datePublished: DateTime
  description: String
  author: BookAuthorUpdateOneRequiredWithoutBooksInput
  coverImage: String
  images: BookUpdateimagesInput
}

input BookUpdateWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput!
  data: BookUpdateDataInput!
}

input BookUpdateWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput!
  data: BookUpdateWithoutAuthorDataInput!
}

input BookUpdateWithWhereUniqueWithoutHashtagsInput {
  where: BookWhereUniqueInput!
  data: BookUpdateWithoutHashtagsDataInput!
}

input BookUpsertNestedInput {
  update: BookUpdateDataInput!
  create: BookCreateInput!
}

input BookUpsertWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput!
  update: BookUpdateDataInput!
  create: BookCreateInput!
}

input BookUpsertWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput!
  update: BookUpdateWithoutAuthorDataInput!
  create: BookCreateWithoutAuthorInput!
}

input BookUpsertWithWhereUniqueWithoutHashtagsInput {
  where: BookWhereUniqueInput!
  update: BookUpdateWithoutHashtagsDataInput!
  create: BookCreateWithoutHashtagsInput!
}

input BookWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  datePublished: DateTime
  datePublished_not: DateTime
  datePublished_in: [DateTime!]
  datePublished_not_in: [DateTime!]
  datePublished_lt: DateTime
  datePublished_lte: DateTime
  datePublished_gt: DateTime
  datePublished_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  hashtags_every: BookHashtagWhereInput
  hashtags_some: BookHashtagWhereInput
  hashtags_none: BookHashtagWhereInput
  author: BookAuthorWhereInput
  coverImage: String
  coverImage_not: String
  coverImage_in: [String!]
  coverImage_not_in: [String!]
  coverImage_lt: String
  coverImage_lte: String
  coverImage_gt: String
  coverImage_gte: String
  coverImage_contains: String
  coverImage_not_contains: String
  coverImage_starts_with: String
  coverImage_not_starts_with: String
  coverImage_ends_with: String
  coverImage_not_ends_with: String
  AND: [BookWhereInput!]
  OR: [BookWhereInput!]
  NOT: [BookWhereInput!]
}

input BookWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createBook(data: BookCreateInput!): Book!
  updateBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateManyBooks(data: BookUpdateManyMutationInput!, where: BookWhereInput): BatchPayload!
  upsertBook(where: BookWhereUniqueInput!, create: BookCreateInput!, update: BookUpdateInput!): Book!
  deleteBook(where: BookWhereUniqueInput!): Book
  deleteManyBooks(where: BookWhereInput): BatchPayload!
  createBookAuthor(data: BookAuthorCreateInput!): BookAuthor!
  updateBookAuthor(data: BookAuthorUpdateInput!, where: BookAuthorWhereUniqueInput!): BookAuthor
  updateManyBookAuthors(data: BookAuthorUpdateManyMutationInput!, where: BookAuthorWhereInput): BatchPayload!
  upsertBookAuthor(where: BookAuthorWhereUniqueInput!, create: BookAuthorCreateInput!, update: BookAuthorUpdateInput!): BookAuthor!
  deleteBookAuthor(where: BookAuthorWhereUniqueInput!): BookAuthor
  deleteManyBookAuthors(where: BookAuthorWhereInput): BatchPayload!
  createBookCategory(data: BookCategoryCreateInput!): BookCategory!
  updateBookCategory(data: BookCategoryUpdateInput!, where: BookCategoryWhereUniqueInput!): BookCategory
  updateManyBookCategories(data: BookCategoryUpdateManyMutationInput!, where: BookCategoryWhereInput): BatchPayload!
  upsertBookCategory(where: BookCategoryWhereUniqueInput!, create: BookCategoryCreateInput!, update: BookCategoryUpdateInput!): BookCategory!
  deleteBookCategory(where: BookCategoryWhereUniqueInput!): BookCategory
  deleteManyBookCategories(where: BookCategoryWhereInput): BatchPayload!
  createBookHashtag(data: BookHashtagCreateInput!): BookHashtag!
  updateBookHashtag(data: BookHashtagUpdateInput!, where: BookHashtagWhereUniqueInput!): BookHashtag
  updateManyBookHashtags(data: BookHashtagUpdateManyMutationInput!, where: BookHashtagWhereInput): BatchPayload!
  upsertBookHashtag(where: BookHashtagWhereUniqueInput!, create: BookHashtagCreateInput!, update: BookHashtagUpdateInput!): BookHashtag!
  deleteBookHashtag(where: BookHashtagWhereUniqueInput!): BookHashtag
  deleteManyBookHashtags(where: BookHashtagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserBookRead(data: UserBookReadCreateInput!): UserBookRead!
  updateUserBookRead(data: UserBookReadUpdateInput!, where: UserBookReadWhereUniqueInput!): UserBookRead
  updateManyUserBookReads(data: UserBookReadUpdateManyMutationInput!, where: UserBookReadWhereInput): BatchPayload!
  upsertUserBookRead(where: UserBookReadWhereUniqueInput!, create: UserBookReadCreateInput!, update: UserBookReadUpdateInput!): UserBookRead!
  deleteUserBookRead(where: UserBookReadWhereUniqueInput!): UserBookRead
  deleteManyUserBookReads(where: UserBookReadWhereInput): BatchPayload!
  createUserBookWant(data: UserBookWantCreateInput!): UserBookWant!
  updateUserBookWant(data: UserBookWantUpdateInput!, where: UserBookWantWhereUniqueInput!): UserBookWant
  upsertUserBookWant(where: UserBookWantWhereUniqueInput!, create: UserBookWantCreateInput!, update: UserBookWantUpdateInput!): UserBookWant!
  deleteUserBookWant(where: UserBookWantWhereUniqueInput!): UserBookWant
  deleteManyUserBookWants(where: UserBookWantWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  book(where: BookWhereUniqueInput!): Book
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book]!
  booksConnection(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookConnection!
  bookAuthor(where: BookAuthorWhereUniqueInput!): BookAuthor
  bookAuthors(where: BookAuthorWhereInput, orderBy: BookAuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookAuthor]!
  bookAuthorsConnection(where: BookAuthorWhereInput, orderBy: BookAuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookAuthorConnection!
  bookCategory(where: BookCategoryWhereUniqueInput!): BookCategory
  bookCategories(where: BookCategoryWhereInput, orderBy: BookCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookCategory]!
  bookCategoriesConnection(where: BookCategoryWhereInput, orderBy: BookCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookCategoryConnection!
  bookHashtag(where: BookHashtagWhereUniqueInput!): BookHashtag
  bookHashtags(where: BookHashtagWhereInput, orderBy: BookHashtagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookHashtag]!
  bookHashtagsConnection(where: BookHashtagWhereInput, orderBy: BookHashtagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookHashtagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userBookRead(where: UserBookReadWhereUniqueInput!): UserBookRead
  userBookReads(where: UserBookReadWhereInput, orderBy: UserBookReadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserBookRead]!
  userBookReadsConnection(where: UserBookReadWhereInput, orderBy: UserBookReadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserBookReadConnection!
  userBookWant(where: UserBookWantWhereUniqueInput!): UserBookWant
  userBookWants(where: UserBookWantWhereInput, orderBy: UserBookWantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserBookWant]!
  userBookWantsConnection(where: UserBookWantWhereInput, orderBy: UserBookWantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserBookWantConnection!
  node(id: ID!): Node
}

type Subscription {
  book(where: BookSubscriptionWhereInput): BookSubscriptionPayload
  bookAuthor(where: BookAuthorSubscriptionWhereInput): BookAuthorSubscriptionPayload
  bookCategory(where: BookCategorySubscriptionWhereInput): BookCategorySubscriptionPayload
  bookHashtag(where: BookHashtagSubscriptionWhereInput): BookHashtagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userBookRead(where: UserBookReadSubscriptionWhereInput): UserBookReadSubscriptionPayload
  userBookWant(where: UserBookWantSubscriptionWhereInput): UserBookWantSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  dateCreated: DateTime!
  dateUpdated: DateTime!
  email: String!
  bookReads(where: UserBookReadWhereInput, orderBy: UserBookReadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserBookRead!]
  bookWants(where: UserBookWantWhereInput, orderBy: UserBookWantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserBookWant!]
}

type UserBookRead {
  id: ID!
  dateCreated: DateTime!
  rating: Int!
  comment: String!
  user: User!
  book: Book!
}

type UserBookReadConnection {
  pageInfo: PageInfo!
  edges: [UserBookReadEdge]!
  aggregate: AggregateUserBookRead!
}

input UserBookReadCreateInput {
  id: ID
  rating: Int!
  comment: String!
  user: UserCreateOneWithoutBookReadsInput!
  book: BookCreateOneInput!
}

input UserBookReadCreateManyWithoutUserInput {
  create: [UserBookReadCreateWithoutUserInput!]
  connect: [UserBookReadWhereUniqueInput!]
}

input UserBookReadCreateWithoutUserInput {
  id: ID
  rating: Int!
  comment: String!
  book: BookCreateOneInput!
}

type UserBookReadEdge {
  node: UserBookRead!
  cursor: String!
}

enum UserBookReadOrderByInput {
  id_ASC
  id_DESC
  dateCreated_ASC
  dateCreated_DESC
  rating_ASC
  rating_DESC
  comment_ASC
  comment_DESC
}

type UserBookReadPreviousValues {
  id: ID!
  dateCreated: DateTime!
  rating: Int!
  comment: String!
}

input UserBookReadScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [UserBookReadScalarWhereInput!]
  OR: [UserBookReadScalarWhereInput!]
  NOT: [UserBookReadScalarWhereInput!]
}

type UserBookReadSubscriptionPayload {
  mutation: MutationType!
  node: UserBookRead
  updatedFields: [String!]
  previousValues: UserBookReadPreviousValues
}

input UserBookReadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserBookReadWhereInput
  AND: [UserBookReadSubscriptionWhereInput!]
  OR: [UserBookReadSubscriptionWhereInput!]
  NOT: [UserBookReadSubscriptionWhereInput!]
}

input UserBookReadUpdateInput {
  rating: Int
  comment: String
  user: UserUpdateOneRequiredWithoutBookReadsInput
  book: BookUpdateOneRequiredInput
}

input UserBookReadUpdateManyDataInput {
  rating: Int
  comment: String
}

input UserBookReadUpdateManyMutationInput {
  rating: Int
  comment: String
}

input UserBookReadUpdateManyWithoutUserInput {
  create: [UserBookReadCreateWithoutUserInput!]
  delete: [UserBookReadWhereUniqueInput!]
  connect: [UserBookReadWhereUniqueInput!]
  set: [UserBookReadWhereUniqueInput!]
  disconnect: [UserBookReadWhereUniqueInput!]
  update: [UserBookReadUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UserBookReadUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [UserBookReadScalarWhereInput!]
  updateMany: [UserBookReadUpdateManyWithWhereNestedInput!]
}

input UserBookReadUpdateManyWithWhereNestedInput {
  where: UserBookReadScalarWhereInput!
  data: UserBookReadUpdateManyDataInput!
}

input UserBookReadUpdateWithoutUserDataInput {
  rating: Int
  comment: String
  book: BookUpdateOneRequiredInput
}

input UserBookReadUpdateWithWhereUniqueWithoutUserInput {
  where: UserBookReadWhereUniqueInput!
  data: UserBookReadUpdateWithoutUserDataInput!
}

input UserBookReadUpsertWithWhereUniqueWithoutUserInput {
  where: UserBookReadWhereUniqueInput!
  update: UserBookReadUpdateWithoutUserDataInput!
  create: UserBookReadCreateWithoutUserInput!
}

input UserBookReadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  user: UserWhereInput
  book: BookWhereInput
  AND: [UserBookReadWhereInput!]
  OR: [UserBookReadWhereInput!]
  NOT: [UserBookReadWhereInput!]
}

input UserBookReadWhereUniqueInput {
  id: ID
}

type UserBookWant {
  id: ID!
  dateCreated: DateTime!
  user: User!
  book: Book!
}

type UserBookWantConnection {
  pageInfo: PageInfo!
  edges: [UserBookWantEdge]!
  aggregate: AggregateUserBookWant!
}

input UserBookWantCreateInput {
  id: ID
  user: UserCreateOneWithoutBookWantsInput!
  book: BookCreateOneInput!
}

input UserBookWantCreateManyWithoutUserInput {
  create: [UserBookWantCreateWithoutUserInput!]
  connect: [UserBookWantWhereUniqueInput!]
}

input UserBookWantCreateWithoutUserInput {
  id: ID
  book: BookCreateOneInput!
}

type UserBookWantEdge {
  node: UserBookWant!
  cursor: String!
}

enum UserBookWantOrderByInput {
  id_ASC
  id_DESC
  dateCreated_ASC
  dateCreated_DESC
}

type UserBookWantPreviousValues {
  id: ID!
  dateCreated: DateTime!
}

input UserBookWantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  AND: [UserBookWantScalarWhereInput!]
  OR: [UserBookWantScalarWhereInput!]
  NOT: [UserBookWantScalarWhereInput!]
}

type UserBookWantSubscriptionPayload {
  mutation: MutationType!
  node: UserBookWant
  updatedFields: [String!]
  previousValues: UserBookWantPreviousValues
}

input UserBookWantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserBookWantWhereInput
  AND: [UserBookWantSubscriptionWhereInput!]
  OR: [UserBookWantSubscriptionWhereInput!]
  NOT: [UserBookWantSubscriptionWhereInput!]
}

input UserBookWantUpdateInput {
  user: UserUpdateOneRequiredWithoutBookWantsInput
  book: BookUpdateOneRequiredInput
}

input UserBookWantUpdateManyWithoutUserInput {
  create: [UserBookWantCreateWithoutUserInput!]
  delete: [UserBookWantWhereUniqueInput!]
  connect: [UserBookWantWhereUniqueInput!]
  set: [UserBookWantWhereUniqueInput!]
  disconnect: [UserBookWantWhereUniqueInput!]
  update: [UserBookWantUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UserBookWantUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [UserBookWantScalarWhereInput!]
}

input UserBookWantUpdateWithoutUserDataInput {
  book: BookUpdateOneRequiredInput
}

input UserBookWantUpdateWithWhereUniqueWithoutUserInput {
  where: UserBookWantWhereUniqueInput!
  data: UserBookWantUpdateWithoutUserDataInput!
}

input UserBookWantUpsertWithWhereUniqueWithoutUserInput {
  where: UserBookWantWhereUniqueInput!
  update: UserBookWantUpdateWithoutUserDataInput!
  create: UserBookWantCreateWithoutUserInput!
}

input UserBookWantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  user: UserWhereInput
  book: BookWhereInput
  AND: [UserBookWantWhereInput!]
  OR: [UserBookWantWhereInput!]
  NOT: [UserBookWantWhereInput!]
}

input UserBookWantWhereUniqueInput {
  id: ID
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  bookReads: UserBookReadCreateManyWithoutUserInput
  bookWants: UserBookWantCreateManyWithoutUserInput
}

input UserCreateOneWithoutBookReadsInput {
  create: UserCreateWithoutBookReadsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBookWantsInput {
  create: UserCreateWithoutBookWantsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBookReadsInput {
  id: ID
  name: String!
  email: String!
  bookWants: UserBookWantCreateManyWithoutUserInput
}

input UserCreateWithoutBookWantsInput {
  id: ID
  name: String!
  email: String!
  bookReads: UserBookReadCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  dateCreated_ASC
  dateCreated_DESC
  dateUpdated_ASC
  dateUpdated_DESC
  email_ASC
  email_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  dateCreated: DateTime!
  dateUpdated: DateTime!
  email: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  bookReads: UserBookReadUpdateManyWithoutUserInput
  bookWants: UserBookWantUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
}

input UserUpdateOneRequiredWithoutBookReadsInput {
  create: UserCreateWithoutBookReadsInput
  update: UserUpdateWithoutBookReadsDataInput
  upsert: UserUpsertWithoutBookReadsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBookWantsInput {
  create: UserCreateWithoutBookWantsInput
  update: UserUpdateWithoutBookWantsDataInput
  upsert: UserUpsertWithoutBookWantsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBookReadsDataInput {
  name: String
  email: String
  bookWants: UserBookWantUpdateManyWithoutUserInput
}

input UserUpdateWithoutBookWantsDataInput {
  name: String
  email: String
  bookReads: UserBookReadUpdateManyWithoutUserInput
}

input UserUpsertWithoutBookReadsInput {
  update: UserUpdateWithoutBookReadsDataInput!
  create: UserCreateWithoutBookReadsInput!
}

input UserUpsertWithoutBookWantsInput {
  update: UserUpdateWithoutBookWantsDataInput!
  create: UserCreateWithoutBookWantsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  dateCreated: DateTime
  dateCreated_not: DateTime
  dateCreated_in: [DateTime!]
  dateCreated_not_in: [DateTime!]
  dateCreated_lt: DateTime
  dateCreated_lte: DateTime
  dateCreated_gt: DateTime
  dateCreated_gte: DateTime
  dateUpdated: DateTime
  dateUpdated_not: DateTime
  dateUpdated_in: [DateTime!]
  dateUpdated_not_in: [DateTime!]
  dateUpdated_lt: DateTime
  dateUpdated_lte: DateTime
  dateUpdated_gt: DateTime
  dateUpdated_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  bookReads_every: UserBookReadWhereInput
  bookReads_some: UserBookReadWhereInput
  bookReads_none: UserBookReadWhereInput
  bookWants_every: UserBookWantWhereInput
  bookWants_some: UserBookWantWhereInput
  bookWants_none: UserBookWantWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`