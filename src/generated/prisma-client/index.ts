// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  book: (where?: BookWhereInput) => Promise<boolean>;
  bookAuthor: (where?: BookAuthorWhereInput) => Promise<boolean>;
  bookCategory: (where?: BookCategoryWhereInput) => Promise<boolean>;
  bookHashtag: (where?: BookHashtagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userBookRead: (where?: UserBookReadWhereInput) => Promise<boolean>;
  userBookWant: (where?: UserBookWantWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  book: (where: BookWhereUniqueInput) => BookNullablePromise;
  books: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Book>;
  booksConnection: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookConnectionPromise;
  bookAuthor: (where: BookAuthorWhereUniqueInput) => BookAuthorNullablePromise;
  bookAuthors: (args?: {
    where?: BookAuthorWhereInput;
    orderBy?: BookAuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BookAuthor>;
  bookAuthorsConnection: (args?: {
    where?: BookAuthorWhereInput;
    orderBy?: BookAuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookAuthorConnectionPromise;
  bookCategory: (
    where: BookCategoryWhereUniqueInput
  ) => BookCategoryNullablePromise;
  bookCategories: (args?: {
    where?: BookCategoryWhereInput;
    orderBy?: BookCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BookCategory>;
  bookCategoriesConnection: (args?: {
    where?: BookCategoryWhereInput;
    orderBy?: BookCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookCategoryConnectionPromise;
  bookHashtag: (
    where: BookHashtagWhereUniqueInput
  ) => BookHashtagNullablePromise;
  bookHashtags: (args?: {
    where?: BookHashtagWhereInput;
    orderBy?: BookHashtagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BookHashtag>;
  bookHashtagsConnection: (args?: {
    where?: BookHashtagWhereInput;
    orderBy?: BookHashtagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookHashtagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userBookRead: (
    where: UserBookReadWhereUniqueInput
  ) => UserBookReadNullablePromise;
  userBookReads: (args?: {
    where?: UserBookReadWhereInput;
    orderBy?: UserBookReadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserBookRead>;
  userBookReadsConnection: (args?: {
    where?: UserBookReadWhereInput;
    orderBy?: UserBookReadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserBookReadConnectionPromise;
  userBookWant: (
    where: UserBookWantWhereUniqueInput
  ) => UserBookWantNullablePromise;
  userBookWants: (args?: {
    where?: UserBookWantWhereInput;
    orderBy?: UserBookWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserBookWant>;
  userBookWantsConnection: (args?: {
    where?: UserBookWantWhereInput;
    orderBy?: UserBookWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserBookWantConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBook: (data: BookCreateInput) => BookPromise;
  updateBook: (args: {
    data: BookUpdateInput;
    where: BookWhereUniqueInput;
  }) => BookPromise;
  updateManyBooks: (args: {
    data: BookUpdateManyMutationInput;
    where?: BookWhereInput;
  }) => BatchPayloadPromise;
  upsertBook: (args: {
    where: BookWhereUniqueInput;
    create: BookCreateInput;
    update: BookUpdateInput;
  }) => BookPromise;
  deleteBook: (where: BookWhereUniqueInput) => BookPromise;
  deleteManyBooks: (where?: BookWhereInput) => BatchPayloadPromise;
  createBookAuthor: (data: BookAuthorCreateInput) => BookAuthorPromise;
  updateBookAuthor: (args: {
    data: BookAuthorUpdateInput;
    where: BookAuthorWhereUniqueInput;
  }) => BookAuthorPromise;
  updateManyBookAuthors: (args: {
    data: BookAuthorUpdateManyMutationInput;
    where?: BookAuthorWhereInput;
  }) => BatchPayloadPromise;
  upsertBookAuthor: (args: {
    where: BookAuthorWhereUniqueInput;
    create: BookAuthorCreateInput;
    update: BookAuthorUpdateInput;
  }) => BookAuthorPromise;
  deleteBookAuthor: (where: BookAuthorWhereUniqueInput) => BookAuthorPromise;
  deleteManyBookAuthors: (where?: BookAuthorWhereInput) => BatchPayloadPromise;
  createBookCategory: (data: BookCategoryCreateInput) => BookCategoryPromise;
  updateBookCategory: (args: {
    data: BookCategoryUpdateInput;
    where: BookCategoryWhereUniqueInput;
  }) => BookCategoryPromise;
  updateManyBookCategories: (args: {
    data: BookCategoryUpdateManyMutationInput;
    where?: BookCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertBookCategory: (args: {
    where: BookCategoryWhereUniqueInput;
    create: BookCategoryCreateInput;
    update: BookCategoryUpdateInput;
  }) => BookCategoryPromise;
  deleteBookCategory: (
    where: BookCategoryWhereUniqueInput
  ) => BookCategoryPromise;
  deleteManyBookCategories: (
    where?: BookCategoryWhereInput
  ) => BatchPayloadPromise;
  createBookHashtag: (data: BookHashtagCreateInput) => BookHashtagPromise;
  updateBookHashtag: (args: {
    data: BookHashtagUpdateInput;
    where: BookHashtagWhereUniqueInput;
  }) => BookHashtagPromise;
  updateManyBookHashtags: (args: {
    data: BookHashtagUpdateManyMutationInput;
    where?: BookHashtagWhereInput;
  }) => BatchPayloadPromise;
  upsertBookHashtag: (args: {
    where: BookHashtagWhereUniqueInput;
    create: BookHashtagCreateInput;
    update: BookHashtagUpdateInput;
  }) => BookHashtagPromise;
  deleteBookHashtag: (where: BookHashtagWhereUniqueInput) => BookHashtagPromise;
  deleteManyBookHashtags: (
    where?: BookHashtagWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserBookRead: (data: UserBookReadCreateInput) => UserBookReadPromise;
  updateUserBookRead: (args: {
    data: UserBookReadUpdateInput;
    where: UserBookReadWhereUniqueInput;
  }) => UserBookReadPromise;
  updateManyUserBookReads: (args: {
    data: UserBookReadUpdateManyMutationInput;
    where?: UserBookReadWhereInput;
  }) => BatchPayloadPromise;
  upsertUserBookRead: (args: {
    where: UserBookReadWhereUniqueInput;
    create: UserBookReadCreateInput;
    update: UserBookReadUpdateInput;
  }) => UserBookReadPromise;
  deleteUserBookRead: (
    where: UserBookReadWhereUniqueInput
  ) => UserBookReadPromise;
  deleteManyUserBookReads: (
    where?: UserBookReadWhereInput
  ) => BatchPayloadPromise;
  createUserBookWant: (data: UserBookWantCreateInput) => UserBookWantPromise;
  updateUserBookWant: (args: {
    data: UserBookWantUpdateInput;
    where: UserBookWantWhereUniqueInput;
  }) => UserBookWantPromise;
  upsertUserBookWant: (args: {
    where: UserBookWantWhereUniqueInput;
    create: UserBookWantCreateInput;
    update: UserBookWantUpdateInput;
  }) => UserBookWantPromise;
  deleteUserBookWant: (
    where: UserBookWantWhereUniqueInput
  ) => UserBookWantPromise;
  deleteManyUserBookWants: (
    where?: UserBookWantWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  book: (
    where?: BookSubscriptionWhereInput
  ) => BookSubscriptionPayloadSubscription;
  bookAuthor: (
    where?: BookAuthorSubscriptionWhereInput
  ) => BookAuthorSubscriptionPayloadSubscription;
  bookCategory: (
    where?: BookCategorySubscriptionWhereInput
  ) => BookCategorySubscriptionPayloadSubscription;
  bookHashtag: (
    where?: BookHashtagSubscriptionWhereInput
  ) => BookHashtagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userBookRead: (
    where?: UserBookReadSubscriptionWhereInput
  ) => UserBookReadSubscriptionPayloadSubscription;
  userBookWant: (
    where?: UserBookWantSubscriptionWhereInput
  ) => UserBookWantSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BookHashtagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type BookOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "datePublished_ASC"
  | "datePublished_DESC"
  | "description_ASC"
  | "description_DESC"
  | "ratingAverage_ASC"
  | "ratingAverage_DESC"
  | "dateCreated_ASC"
  | "dateCreated_DESC"
  | "coverImage_ASC"
  | "coverImage_DESC";

export type BookAuthorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type BookCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserBookReadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateCreated_ASC"
  | "dateCreated_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "comment_ASC"
  | "comment_DESC";

export type UserBookWantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateCreated_ASC"
  | "dateCreated_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "dateCreated_ASC"
  | "dateCreated_DESC"
  | "dateUpdated_ASC"
  | "dateUpdated_DESC"
  | "email_ASC"
  | "email_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface BookUpdateWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput;
  data: BookUpdateWithoutAuthorDataInput;
}

export type BookWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookHashtagUpdateManyWithoutBooksInput {
  create?: Maybe<
    BookHashtagCreateWithoutBooksInput[] | BookHashtagCreateWithoutBooksInput
  >;
  delete?: Maybe<BookHashtagWhereUniqueInput[] | BookHashtagWhereUniqueInput>;
  connect?: Maybe<BookHashtagWhereUniqueInput[] | BookHashtagWhereUniqueInput>;
  set?: Maybe<BookHashtagWhereUniqueInput[] | BookHashtagWhereUniqueInput>;
  disconnect?: Maybe<
    BookHashtagWhereUniqueInput[] | BookHashtagWhereUniqueInput
  >;
  update?: Maybe<
    | BookHashtagUpdateWithWhereUniqueWithoutBooksInput[]
    | BookHashtagUpdateWithWhereUniqueWithoutBooksInput
  >;
  upsert?: Maybe<
    | BookHashtagUpsertWithWhereUniqueWithoutBooksInput[]
    | BookHashtagUpsertWithWhereUniqueWithoutBooksInput
  >;
  deleteMany?: Maybe<
    BookHashtagScalarWhereInput[] | BookHashtagScalarWhereInput
  >;
  updateMany?: Maybe<
    | BookHashtagUpdateManyWithWhereNestedInput[]
    | BookHashtagUpdateManyWithWhereNestedInput
  >;
}

export interface UserBookReadUpdateWithoutUserDataInput {
  rating?: Maybe<Int>;
  comment?: Maybe<String>;
  book?: Maybe<BookUpdateOneRequiredInput>;
}

export interface BookHashtagUpdateWithWhereUniqueWithoutBooksInput {
  where: BookHashtagWhereUniqueInput;
  data: BookHashtagUpdateWithoutBooksDataInput;
}

export interface BookUpdateManyDataInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface BookHashtagUpdateWithoutBooksDataInput {
  name?: Maybe<String>;
}

export interface UserBookReadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserBookReadWhereInput>;
  AND?: Maybe<
    UserBookReadSubscriptionWhereInput[] | UserBookReadSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserBookReadSubscriptionWhereInput[] | UserBookReadSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserBookReadSubscriptionWhereInput[] | UserBookReadSubscriptionWhereInput
  >;
}

export interface BookHashtagUpsertWithWhereUniqueWithoutBooksInput {
  where: BookHashtagWhereUniqueInput;
  update: BookHashtagUpdateWithoutBooksDataInput;
  create: BookHashtagCreateWithoutBooksInput;
}

export interface BookHashtagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookHashtagWhereInput>;
  AND?: Maybe<
    BookHashtagSubscriptionWhereInput[] | BookHashtagSubscriptionWhereInput
  >;
  OR?: Maybe<
    BookHashtagSubscriptionWhereInput[] | BookHashtagSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BookHashtagSubscriptionWhereInput[] | BookHashtagSubscriptionWhereInput
  >;
}

export interface BookHashtagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<BookHashtagScalarWhereInput[] | BookHashtagScalarWhereInput>;
  OR?: Maybe<BookHashtagScalarWhereInput[] | BookHashtagScalarWhereInput>;
  NOT?: Maybe<BookHashtagScalarWhereInput[] | BookHashtagScalarWhereInput>;
}

export interface BookAuthorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookAuthorWhereInput>;
  AND?: Maybe<
    BookAuthorSubscriptionWhereInput[] | BookAuthorSubscriptionWhereInput
  >;
  OR?: Maybe<
    BookAuthorSubscriptionWhereInput[] | BookAuthorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BookAuthorSubscriptionWhereInput[] | BookAuthorSubscriptionWhereInput
  >;
}

export interface BookHashtagUpdateManyWithWhereNestedInput {
  where: BookHashtagScalarWhereInput;
  data: BookHashtagUpdateManyDataInput;
}

export interface BookWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  datePublished_not?: Maybe<DateTimeInput>;
  datePublished_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePublished_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePublished_lt?: Maybe<DateTimeInput>;
  datePublished_lte?: Maybe<DateTimeInput>;
  datePublished_gt?: Maybe<DateTimeInput>;
  datePublished_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  ratingAverage_not?: Maybe<Int>;
  ratingAverage_in?: Maybe<Int[] | Int>;
  ratingAverage_not_in?: Maybe<Int[] | Int>;
  ratingAverage_lt?: Maybe<Int>;
  ratingAverage_lte?: Maybe<Int>;
  ratingAverage_gt?: Maybe<Int>;
  ratingAverage_gte?: Maybe<Int>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  hashtags_every?: Maybe<BookHashtagWhereInput>;
  hashtags_some?: Maybe<BookHashtagWhereInput>;
  hashtags_none?: Maybe<BookHashtagWhereInput>;
  author?: Maybe<BookAuthorWhereInput>;
  coverImage?: Maybe<String>;
  coverImage_not?: Maybe<String>;
  coverImage_in?: Maybe<String[] | String>;
  coverImage_not_in?: Maybe<String[] | String>;
  coverImage_lt?: Maybe<String>;
  coverImage_lte?: Maybe<String>;
  coverImage_gt?: Maybe<String>;
  coverImage_gte?: Maybe<String>;
  coverImage_contains?: Maybe<String>;
  coverImage_not_contains?: Maybe<String>;
  coverImage_starts_with?: Maybe<String>;
  coverImage_not_starts_with?: Maybe<String>;
  coverImage_ends_with?: Maybe<String>;
  coverImage_not_ends_with?: Maybe<String>;
  AND?: Maybe<BookWhereInput[] | BookWhereInput>;
  OR?: Maybe<BookWhereInput[] | BookWhereInput>;
  NOT?: Maybe<BookWhereInput[] | BookWhereInput>;
}

export interface BookHashtagUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpsertWithoutBookWantsInput {
  update: UserUpdateWithoutBookWantsDataInput;
  create: UserCreateWithoutBookWantsInput;
}

export interface BookAuthorUpdateOneRequiredWithoutBooksInput {
  create?: Maybe<BookAuthorCreateWithoutBooksInput>;
  update?: Maybe<BookAuthorUpdateWithoutBooksDataInput>;
  upsert?: Maybe<BookAuthorUpsertWithoutBooksInput>;
  connect?: Maybe<BookAuthorWhereUniqueInput>;
}

export type BookCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BookAuthorUpdateWithoutBooksDataInput {
  name?: Maybe<String>;
}

export interface BookCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  books_every?: Maybe<BookWhereInput>;
  books_some?: Maybe<BookWhereInput>;
  books_none?: Maybe<BookWhereInput>;
  AND?: Maybe<BookCategoryWhereInput[] | BookCategoryWhereInput>;
  OR?: Maybe<BookCategoryWhereInput[] | BookCategoryWhereInput>;
  NOT?: Maybe<BookCategoryWhereInput[] | BookCategoryWhereInput>;
}

export interface BookAuthorUpsertWithoutBooksInput {
  update: BookAuthorUpdateWithoutBooksDataInput;
  create: BookAuthorCreateWithoutBooksInput;
}

export interface UserBookWantUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutBookWantsInput>;
  book?: Maybe<BookUpdateOneRequiredInput>;
}

export interface BookUpdateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface UserCreateOneWithoutBookWantsInput {
  create?: Maybe<UserCreateWithoutBookWantsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookUpdateManyMutationInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface UserBookWantCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutBookWantsInput;
  book: BookCreateOneInput;
}

export interface UserBookReadUpsertWithWhereUniqueWithoutUserInput {
  where: UserBookReadWhereUniqueInput;
  update: UserBookReadUpdateWithoutUserDataInput;
  create: UserBookReadCreateWithoutUserInput;
}

export interface UserUpsertWithoutBookReadsInput {
  update: UserUpdateWithoutBookReadsDataInput;
  create: UserCreateWithoutBookReadsInput;
}

export interface BookUpsertNestedInput {
  update: BookUpdateDataInput;
  create: BookCreateInput;
}

export interface UserUpdateWithoutBookReadsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  bookWants?: Maybe<UserBookWantUpdateManyWithoutUserInput>;
}

export interface BookAuthorCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  books?: Maybe<BookCreateManyWithoutAuthorInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  dateUpdated?: Maybe<DateTimeInput>;
  dateUpdated_not?: Maybe<DateTimeInput>;
  dateUpdated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateUpdated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateUpdated_lt?: Maybe<DateTimeInput>;
  dateUpdated_lte?: Maybe<DateTimeInput>;
  dateUpdated_gt?: Maybe<DateTimeInput>;
  dateUpdated_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  bookReads_every?: Maybe<UserBookReadWhereInput>;
  bookReads_some?: Maybe<UserBookReadWhereInput>;
  bookReads_none?: Maybe<UserBookReadWhereInput>;
  bookWants_every?: Maybe<UserBookWantWhereInput>;
  bookWants_some?: Maybe<UserBookWantWhereInput>;
  bookWants_none?: Maybe<UserBookWantWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BookCreateManyWithoutAuthorInput {
  create?: Maybe<BookCreateWithoutAuthorInput[] | BookCreateWithoutAuthorInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutBookReadsInput {
  create?: Maybe<UserCreateWithoutBookReadsInput>;
  update?: Maybe<UserUpdateWithoutBookReadsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBookReadsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  name: String;
  datePublished: DateTimeInput;
  description: String;
  ratingAverage: Int;
  hashtags?: Maybe<BookHashtagCreateManyWithoutBooksInput>;
  coverImage: String;
  images?: Maybe<BookCreateimagesInput>;
}

export interface UserCreateWithoutBookReadsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  bookWants?: Maybe<UserBookWantCreateManyWithoutUserInput>;
}

export interface BookAuthorUpdateInput {
  name?: Maybe<String>;
  books?: Maybe<BookUpdateManyWithoutAuthorInput>;
}

export interface UserBookReadCreateInput {
  id?: Maybe<ID_Input>;
  rating: Int;
  comment: String;
  user: UserCreateOneWithoutBookReadsInput;
  book: BookCreateOneInput;
}

export interface BookUpdateManyWithoutAuthorInput {
  create?: Maybe<BookCreateWithoutAuthorInput[] | BookCreateWithoutAuthorInput>;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueWithoutAuthorInput[]
    | BookUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueWithoutAuthorInput[]
    | BookUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface UserBookWantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserBookWantScalarWhereInput[] | UserBookWantScalarWhereInput>;
  OR?: Maybe<UserBookWantScalarWhereInput[] | UserBookWantScalarWhereInput>;
  NOT?: Maybe<UserBookWantScalarWhereInput[] | UserBookWantScalarWhereInput>;
}

export interface BookUpdateOneRequiredInput {
  create?: Maybe<BookCreateInput>;
  update?: Maybe<BookUpdateDataInput>;
  upsert?: Maybe<BookUpsertNestedInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export type UserBookReadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookUpdateWithoutAuthorDataInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  hashtags?: Maybe<BookHashtagUpdateManyWithoutBooksInput>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface UserBookWantUpdateWithWhereUniqueWithoutUserInput {
  where: UserBookWantWhereUniqueInput;
  data: UserBookWantUpdateWithoutUserDataInput;
}

export interface BookUpsertWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput;
  update: BookUpdateWithoutAuthorDataInput;
  create: BookCreateWithoutAuthorInput;
}

export type UserBookWantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  datePublished_not?: Maybe<DateTimeInput>;
  datePublished_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePublished_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePublished_lt?: Maybe<DateTimeInput>;
  datePublished_lte?: Maybe<DateTimeInput>;
  datePublished_gt?: Maybe<DateTimeInput>;
  datePublished_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  ratingAverage_not?: Maybe<Int>;
  ratingAverage_in?: Maybe<Int[] | Int>;
  ratingAverage_not_in?: Maybe<Int[] | Int>;
  ratingAverage_lt?: Maybe<Int>;
  ratingAverage_lte?: Maybe<Int>;
  ratingAverage_gt?: Maybe<Int>;
  ratingAverage_gte?: Maybe<Int>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  coverImage?: Maybe<String>;
  coverImage_not?: Maybe<String>;
  coverImage_in?: Maybe<String[] | String>;
  coverImage_not_in?: Maybe<String[] | String>;
  coverImage_lt?: Maybe<String>;
  coverImage_lte?: Maybe<String>;
  coverImage_gt?: Maybe<String>;
  coverImage_gte?: Maybe<String>;
  coverImage_contains?: Maybe<String>;
  coverImage_not_contains?: Maybe<String>;
  coverImage_starts_with?: Maybe<String>;
  coverImage_not_starts_with?: Maybe<String>;
  coverImage_ends_with?: Maybe<String>;
  coverImage_not_ends_with?: Maybe<String>;
  AND?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  OR?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  NOT?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
}

export interface UserBookReadUpdateManyWithWhereNestedInput {
  where: UserBookReadScalarWhereInput;
  data: UserBookReadUpdateManyDataInput;
}

export interface BookUpdateManyWithWhereNestedInput {
  where: BookScalarWhereInput;
  data: BookUpdateManyDataInput;
}

export interface BookHashtagCreateManyWithoutBooksInput {
  create?: Maybe<
    BookHashtagCreateWithoutBooksInput[] | BookHashtagCreateWithoutBooksInput
  >;
  connect?: Maybe<BookHashtagWhereUniqueInput[] | BookHashtagWhereUniqueInput>;
}

export interface BookAuthorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  books_every?: Maybe<BookWhereInput>;
  books_some?: Maybe<BookWhereInput>;
  books_none?: Maybe<BookWhereInput>;
  AND?: Maybe<BookAuthorWhereInput[] | BookAuthorWhereInput>;
  OR?: Maybe<BookAuthorWhereInput[] | BookAuthorWhereInput>;
  NOT?: Maybe<BookAuthorWhereInput[] | BookAuthorWhereInput>;
}

export interface BookAuthorCreateOneWithoutBooksInput {
  create?: Maybe<BookAuthorCreateWithoutBooksInput>;
  connect?: Maybe<BookAuthorWhereUniqueInput>;
}

export interface BookAuthorUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BookCreateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface BookCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  books?: Maybe<BookCreateManyInput>;
}

export interface UserBookWantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserBookWantWhereInput>;
  AND?: Maybe<
    UserBookWantSubscriptionWhereInput[] | UserBookWantSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserBookWantSubscriptionWhereInput[] | UserBookWantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserBookWantSubscriptionWhereInput[] | UserBookWantSubscriptionWhereInput
  >;
}

export interface BookCreateManyInput {
  create?: Maybe<BookCreateInput[] | BookCreateInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface BookCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookCategoryWhereInput>;
  AND?: Maybe<
    BookCategorySubscriptionWhereInput[] | BookCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    BookCategorySubscriptionWhereInput[] | BookCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    BookCategorySubscriptionWhereInput[] | BookCategorySubscriptionWhereInput
  >;
}

export interface BookCategoryUpdateInput {
  name?: Maybe<String>;
  books?: Maybe<BookUpdateManyInput>;
}

export interface BookSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookWhereInput>;
  AND?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  OR?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  NOT?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
}

export interface BookUpdateManyInput {
  create?: Maybe<BookCreateInput[] | BookCreateInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueNestedInput[]
    | BookUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueNestedInput[]
    | BookUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutBookWantsInput {
  create?: Maybe<UserCreateWithoutBookWantsInput>;
  update?: Maybe<UserUpdateWithoutBookWantsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBookWantsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookUpdateWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput;
  data: BookUpdateDataInput;
}

export interface UserCreateWithoutBookWantsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  bookReads?: Maybe<UserBookReadCreateManyWithoutUserInput>;
}

export interface BookUpdateDataInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  hashtags?: Maybe<BookHashtagUpdateManyWithoutBooksInput>;
  author?: Maybe<BookAuthorUpdateOneRequiredWithoutBooksInput>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface UserBookReadUpdateManyMutationInput {
  rating?: Maybe<Int>;
  comment?: Maybe<String>;
}

export interface BookUpsertWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput;
  update: BookUpdateDataInput;
  create: BookCreateInput;
}

export interface UserBookReadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  book?: Maybe<BookWhereInput>;
  AND?: Maybe<UserBookReadWhereInput[] | UserBookReadWhereInput>;
  OR?: Maybe<UserBookReadWhereInput[] | UserBookReadWhereInput>;
  NOT?: Maybe<UserBookReadWhereInput[] | UserBookReadWhereInput>;
}

export interface BookCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserBookReadUpdateInput {
  rating?: Maybe<Int>;
  comment?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutBookReadsInput>;
  book?: Maybe<BookUpdateOneRequiredInput>;
}

export interface BookHashtagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  books?: Maybe<BookCreateManyWithoutHashtagsInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface BookCreateManyWithoutHashtagsInput {
  create?: Maybe<
    BookCreateWithoutHashtagsInput[] | BookCreateWithoutHashtagsInput
  >;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface UserBookWantUpdateWithoutUserDataInput {
  book?: Maybe<BookUpdateOneRequiredInput>;
}

export interface BookCreateWithoutHashtagsInput {
  id?: Maybe<ID_Input>;
  name: String;
  datePublished: DateTimeInput;
  description: String;
  ratingAverage: Int;
  author: BookAuthorCreateOneWithoutBooksInput;
  coverImage: String;
  images?: Maybe<BookCreateimagesInput>;
}

export interface UserBookReadUpdateManyDataInput {
  rating?: Maybe<Int>;
  comment?: Maybe<String>;
}

export interface BookHashtagUpdateInput {
  name?: Maybe<String>;
  books?: Maybe<BookUpdateManyWithoutHashtagsInput>;
}

export interface BookCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  datePublished: DateTimeInput;
  description: String;
  ratingAverage: Int;
  hashtags?: Maybe<BookHashtagCreateManyWithoutBooksInput>;
  author: BookAuthorCreateOneWithoutBooksInput;
  coverImage: String;
  images?: Maybe<BookCreateimagesInput>;
}

export interface BookUpdateManyWithoutHashtagsInput {
  create?: Maybe<
    BookCreateWithoutHashtagsInput[] | BookCreateWithoutHashtagsInput
  >;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueWithoutHashtagsInput[]
    | BookUpdateWithWhereUniqueWithoutHashtagsInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueWithoutHashtagsInput[]
    | BookUpsertWithWhereUniqueWithoutHashtagsInput
  >;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface BookAuthorCreateWithoutBooksInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface BookUpdateWithWhereUniqueWithoutHashtagsInput {
  where: BookWhereUniqueInput;
  data: BookUpdateWithoutHashtagsDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface BookUpdateWithoutHashtagsDataInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  author?: Maybe<BookAuthorUpdateOneRequiredWithoutBooksInput>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface UserUpdateWithoutBookWantsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  bookReads?: Maybe<UserBookReadUpdateManyWithoutUserInput>;
}

export interface BookUpsertWithWhereUniqueWithoutHashtagsInput {
  where: BookWhereUniqueInput;
  update: BookUpdateWithoutHashtagsDataInput;
  create: BookCreateWithoutHashtagsInput;
}

export type BookHashtagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BookHashtagUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserBookWantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  book?: Maybe<BookWhereInput>;
  AND?: Maybe<UserBookWantWhereInput[] | UserBookWantWhereInput>;
  OR?: Maybe<UserBookWantWhereInput[] | UserBookWantWhereInput>;
  NOT?: Maybe<UserBookWantWhereInput[] | UserBookWantWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  bookReads?: Maybe<UserBookReadCreateManyWithoutUserInput>;
  bookWants?: Maybe<UserBookWantCreateManyWithoutUserInput>;
}

export interface UserBookWantUpsertWithWhereUniqueWithoutUserInput {
  where: UserBookWantWhereUniqueInput;
  update: UserBookWantUpdateWithoutUserDataInput;
  create: UserBookWantCreateWithoutUserInput;
}

export interface UserBookReadCreateManyWithoutUserInput {
  create?: Maybe<
    UserBookReadCreateWithoutUserInput[] | UserBookReadCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserBookReadWhereUniqueInput[] | UserBookReadWhereUniqueInput
  >;
}

export interface UserBookReadScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dateCreated?: Maybe<DateTimeInput>;
  dateCreated_not?: Maybe<DateTimeInput>;
  dateCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCreated_lt?: Maybe<DateTimeInput>;
  dateCreated_lte?: Maybe<DateTimeInput>;
  dateCreated_gt?: Maybe<DateTimeInput>;
  dateCreated_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserBookReadScalarWhereInput[] | UserBookReadScalarWhereInput>;
  OR?: Maybe<UserBookReadScalarWhereInput[] | UserBookReadScalarWhereInput>;
  NOT?: Maybe<UserBookReadScalarWhereInput[] | UserBookReadScalarWhereInput>;
}

export interface UserBookReadCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  rating: Int;
  comment: String;
  book: BookCreateOneInput;
}

export interface BookUpdateInput {
  name?: Maybe<String>;
  datePublished?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  ratingAverage?: Maybe<Int>;
  hashtags?: Maybe<BookHashtagUpdateManyWithoutBooksInput>;
  author?: Maybe<BookAuthorUpdateOneRequiredWithoutBooksInput>;
  coverImage?: Maybe<String>;
  images?: Maybe<BookUpdateimagesInput>;
}

export interface BookCreateOneInput {
  create?: Maybe<BookCreateInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface BookHashtagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  books_every?: Maybe<BookWhereInput>;
  books_some?: Maybe<BookWhereInput>;
  books_none?: Maybe<BookWhereInput>;
  AND?: Maybe<BookHashtagWhereInput[] | BookHashtagWhereInput>;
  OR?: Maybe<BookHashtagWhereInput[] | BookHashtagWhereInput>;
  NOT?: Maybe<BookHashtagWhereInput[] | BookHashtagWhereInput>;
}

export interface UserBookWantCreateManyWithoutUserInput {
  create?: Maybe<
    UserBookWantCreateWithoutUserInput[] | UserBookWantCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserBookWantWhereUniqueInput[] | UserBookWantWhereUniqueInput
  >;
}

export interface UserCreateOneWithoutBookReadsInput {
  create?: Maybe<UserCreateWithoutBookReadsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserBookReadUpdateWithWhereUniqueWithoutUserInput {
  where: UserBookReadWhereUniqueInput;
  data: UserBookReadUpdateWithoutUserDataInput;
}

export interface UserBookReadUpdateManyWithoutUserInput {
  create?: Maybe<
    UserBookReadCreateWithoutUserInput[] | UserBookReadCreateWithoutUserInput
  >;
  delete?: Maybe<UserBookReadWhereUniqueInput[] | UserBookReadWhereUniqueInput>;
  connect?: Maybe<
    UserBookReadWhereUniqueInput[] | UserBookReadWhereUniqueInput
  >;
  set?: Maybe<UserBookReadWhereUniqueInput[] | UserBookReadWhereUniqueInput>;
  disconnect?: Maybe<
    UserBookReadWhereUniqueInput[] | UserBookReadWhereUniqueInput
  >;
  update?: Maybe<
    | UserBookReadUpdateWithWhereUniqueWithoutUserInput[]
    | UserBookReadUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserBookReadUpsertWithWhereUniqueWithoutUserInput[]
    | UserBookReadUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserBookReadScalarWhereInput[] | UserBookReadScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserBookReadUpdateManyWithWhereNestedInput[]
    | UserBookReadUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  bookReads?: Maybe<UserBookReadUpdateManyWithoutUserInput>;
  bookWants?: Maybe<UserBookWantUpdateManyWithoutUserInput>;
}

export interface UserBookWantCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  book: BookCreateOneInput;
}

export interface UserBookWantUpdateManyWithoutUserInput {
  create?: Maybe<
    UserBookWantCreateWithoutUserInput[] | UserBookWantCreateWithoutUserInput
  >;
  delete?: Maybe<UserBookWantWhereUniqueInput[] | UserBookWantWhereUniqueInput>;
  connect?: Maybe<
    UserBookWantWhereUniqueInput[] | UserBookWantWhereUniqueInput
  >;
  set?: Maybe<UserBookWantWhereUniqueInput[] | UserBookWantWhereUniqueInput>;
  disconnect?: Maybe<
    UserBookWantWhereUniqueInput[] | UserBookWantWhereUniqueInput
  >;
  update?: Maybe<
    | UserBookWantUpdateWithWhereUniqueWithoutUserInput[]
    | UserBookWantUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserBookWantUpsertWithWhereUniqueWithoutUserInput[]
    | UserBookWantUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserBookWantScalarWhereInput[] | UserBookWantScalarWhereInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type BookAuthorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookHashtagCreateWithoutBooksInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserBookWantPreviousValues {
  id: ID_Output;
  dateCreated: DateTimeOutput;
}

export interface UserBookWantPreviousValuesPromise
  extends Promise<UserBookWantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
}

export interface UserBookWantPreviousValuesSubscription
  extends Promise<AsyncIterator<UserBookWantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookCategory {
  id: ID_Output;
  name: String;
}

export interface BookCategoryPromise
  extends Promise<BookCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookCategorySubscription
  extends Promise<AsyncIterator<BookCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  books: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookCategoryNullablePromise
  extends Promise<BookCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookHashtag {
  id: ID_Output;
  name: String;
}

export interface BookHashtagPromise extends Promise<BookHashtag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookHashtagSubscription
  extends Promise<AsyncIterator<BookHashtag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  books: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookHashtagNullablePromise
  extends Promise<BookHashtag | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateBookAuthor {
  count: Int;
}

export interface AggregateBookAuthorPromise
  extends Promise<AggregateBookAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookAuthorSubscription
  extends Promise<AsyncIterator<AggregateBookAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BookAuthorEdge {
  node: BookAuthor;
  cursor: String;
}

export interface BookAuthorEdgePromise
  extends Promise<BookAuthorEdge>,
    Fragmentable {
  node: <T = BookAuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookAuthorEdgeSubscription
  extends Promise<AsyncIterator<BookAuthorEdge>>,
    Fragmentable {
  node: <T = BookAuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserBookWantEdge {
  node: UserBookWant;
  cursor: String;
}

export interface UserBookWantEdgePromise
  extends Promise<UserBookWantEdge>,
    Fragmentable {
  node: <T = UserBookWantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserBookWantEdgeSubscription
  extends Promise<AsyncIterator<UserBookWantEdge>>,
    Fragmentable {
  node: <T = UserBookWantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookAuthorConnection {
  pageInfo: PageInfo;
  edges: BookAuthorEdge[];
}

export interface BookAuthorConnectionPromise
  extends Promise<BookAuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookAuthorEdge>>() => T;
  aggregate: <T = AggregateBookAuthorPromise>() => T;
}

export interface BookAuthorConnectionSubscription
  extends Promise<AsyncIterator<BookAuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookAuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookAuthorSubscription>() => T;
}

export interface AggregateUserBookRead {
  count: Int;
}

export interface AggregateUserBookReadPromise
  extends Promise<AggregateUserBookRead>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserBookReadSubscription
  extends Promise<AsyncIterator<AggregateUserBookRead>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Book {
  id: ID_Output;
  name: String;
  datePublished: DateTimeOutput;
  description: String;
  ratingAverage: Int;
  dateCreated: DateTimeOutput;
  coverImage: String;
  images: String[];
}

export interface BookPromise extends Promise<Book>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  datePublished: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  ratingAverage: () => Promise<Int>;
  dateCreated: () => Promise<DateTimeOutput>;
  hashtags: <T = FragmentableArray<BookHashtag>>(args?: {
    where?: BookHashtagWhereInput;
    orderBy?: BookHashtagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = BookAuthorPromise>() => T;
  coverImage: () => Promise<String>;
  images: () => Promise<String[]>;
}

export interface BookSubscription
  extends Promise<AsyncIterator<Book>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  datePublished: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  ratingAverage: () => Promise<AsyncIterator<Int>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  hashtags: <T = Promise<AsyncIterator<BookHashtagSubscription>>>(args?: {
    where?: BookHashtagWhereInput;
    orderBy?: BookHashtagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = BookAuthorSubscription>() => T;
  coverImage: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
}

export interface BookNullablePromise
  extends Promise<Book | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  datePublished: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  ratingAverage: () => Promise<Int>;
  dateCreated: () => Promise<DateTimeOutput>;
  hashtags: <T = FragmentableArray<BookHashtag>>(args?: {
    where?: BookHashtagWhereInput;
    orderBy?: BookHashtagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = BookAuthorPromise>() => T;
  coverImage: () => Promise<String>;
  images: () => Promise<String[]>;
}

export interface UserBookReadConnection {
  pageInfo: PageInfo;
  edges: UserBookReadEdge[];
}

export interface UserBookReadConnectionPromise
  extends Promise<UserBookReadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserBookReadEdge>>() => T;
  aggregate: <T = AggregateUserBookReadPromise>() => T;
}

export interface UserBookReadConnectionSubscription
  extends Promise<AsyncIterator<UserBookReadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserBookReadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserBookReadSubscription>() => T;
}

export interface BookSubscriptionPayload {
  mutation: MutationType;
  node: Book;
  updatedFields: String[];
  previousValues: BookPreviousValues;
}

export interface BookSubscriptionPayloadPromise
  extends Promise<BookSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookPreviousValuesPromise>() => T;
}

export interface BookSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookConnection {
  pageInfo: PageInfo;
  edges: BookEdge[];
}

export interface BookConnectionPromise
  extends Promise<BookConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEdge>>() => T;
  aggregate: <T = AggregateBookPromise>() => T;
}

export interface BookConnectionSubscription
  extends Promise<AsyncIterator<BookConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface BookPreviousValues {
  id: ID_Output;
  name: String;
  datePublished: DateTimeOutput;
  description: String;
  ratingAverage: Int;
  dateCreated: DateTimeOutput;
  coverImage: String;
  images: String[];
}

export interface BookPreviousValuesPromise
  extends Promise<BookPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  datePublished: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  ratingAverage: () => Promise<Int>;
  dateCreated: () => Promise<DateTimeOutput>;
  coverImage: () => Promise<String>;
  images: () => Promise<String[]>;
}

export interface BookPreviousValuesSubscription
  extends Promise<AsyncIterator<BookPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  datePublished: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  ratingAverage: () => Promise<AsyncIterator<Int>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  coverImage: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
}

export interface UserBookWant {
  id: ID_Output;
  dateCreated: DateTimeOutput;
}

export interface UserBookWantPromise
  extends Promise<UserBookWant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
}

export interface UserBookWantSubscription
  extends Promise<AsyncIterator<UserBookWant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  book: <T = BookSubscription>() => T;
}

export interface UserBookWantNullablePromise
  extends Promise<UserBookWant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
}

export interface UserBookRead {
  id: ID_Output;
  dateCreated: DateTimeOutput;
  rating: Int;
  comment: String;
}

export interface UserBookReadPromise
  extends Promise<UserBookRead>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
  comment: () => Promise<String>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
}

export interface UserBookReadSubscription
  extends Promise<AsyncIterator<UserBookRead>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<Int>>;
  comment: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  book: <T = BookSubscription>() => T;
}

export interface UserBookReadNullablePromise
  extends Promise<UserBookRead | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
  comment: () => Promise<String>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
}

export interface AggregateBook {
  count: Int;
}

export interface AggregateBookPromise
  extends Promise<AggregateBook>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookSubscription
  extends Promise<AsyncIterator<AggregateBook>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  dateCreated: DateTimeOutput;
  dateUpdated: DateTimeOutput;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dateCreated: () => Promise<DateTimeOutput>;
  dateUpdated: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  bookReads: <T = FragmentableArray<UserBookRead>>(args?: {
    where?: UserBookReadWhereInput;
    orderBy?: UserBookReadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookWants: <T = FragmentableArray<UserBookWant>>(args?: {
    where?: UserBookWantWhereInput;
    orderBy?: UserBookWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  bookReads: <T = Promise<AsyncIterator<UserBookReadSubscription>>>(args?: {
    where?: UserBookReadWhereInput;
    orderBy?: UserBookReadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookWants: <T = Promise<AsyncIterator<UserBookWantSubscription>>>(args?: {
    where?: UserBookWantWhereInput;
    orderBy?: UserBookWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dateCreated: () => Promise<DateTimeOutput>;
  dateUpdated: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  bookReads: <T = FragmentableArray<UserBookRead>>(args?: {
    where?: UserBookReadWhereInput;
    orderBy?: UserBookReadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookWants: <T = FragmentableArray<UserBookWant>>(args?: {
    where?: UserBookWantWhereInput;
    orderBy?: UserBookWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookAuthorSubscriptionPayload {
  mutation: MutationType;
  node: BookAuthor;
  updatedFields: String[];
  previousValues: BookAuthorPreviousValues;
}

export interface BookAuthorSubscriptionPayloadPromise
  extends Promise<BookAuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookAuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookAuthorPreviousValuesPromise>() => T;
}

export interface BookAuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookAuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookAuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookAuthorPreviousValuesSubscription>() => T;
}

export interface BookHashtagEdge {
  node: BookHashtag;
  cursor: String;
}

export interface BookHashtagEdgePromise
  extends Promise<BookHashtagEdge>,
    Fragmentable {
  node: <T = BookHashtagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookHashtagEdgeSubscription
  extends Promise<AsyncIterator<BookHashtagEdge>>,
    Fragmentable {
  node: <T = BookHashtagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookAuthorPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BookAuthorPreviousValuesPromise
  extends Promise<BookAuthorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BookAuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<BookAuthorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookCategory {
  count: Int;
}

export interface AggregateBookCategoryPromise
  extends Promise<AggregateBookCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookCategorySubscription
  extends Promise<AsyncIterator<AggregateBookCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookEdge {
  node: Book;
  cursor: String;
}

export interface BookEdgePromise extends Promise<BookEdge>, Fragmentable {
  node: <T = BookPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEdgeSubscription
  extends Promise<AsyncIterator<BookEdge>>,
    Fragmentable {
  node: <T = BookSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookCategoryConnection {
  pageInfo: PageInfo;
  edges: BookCategoryEdge[];
}

export interface BookCategoryConnectionPromise
  extends Promise<BookCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookCategoryEdge>>() => T;
  aggregate: <T = AggregateBookCategoryPromise>() => T;
}

export interface BookCategoryConnectionSubscription
  extends Promise<AsyncIterator<BookCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookCategorySubscription>() => T;
}

export interface BookCategorySubscriptionPayload {
  mutation: MutationType;
  node: BookCategory;
  updatedFields: String[];
  previousValues: BookCategoryPreviousValues;
}

export interface BookCategorySubscriptionPayloadPromise
  extends Promise<BookCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookCategoryPreviousValuesPromise>() => T;
}

export interface BookCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateUserBookWant {
  count: Int;
}

export interface AggregateUserBookWantPromise
  extends Promise<AggregateUserBookWant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserBookWantSubscription
  extends Promise<AsyncIterator<AggregateUserBookWant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookCategoryPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BookCategoryPreviousValuesPromise
  extends Promise<BookCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BookCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<BookCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserBookReadEdge {
  node: UserBookRead;
  cursor: String;
}

export interface UserBookReadEdgePromise
  extends Promise<UserBookReadEdge>,
    Fragmentable {
  node: <T = UserBookReadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserBookReadEdgeSubscription
  extends Promise<AsyncIterator<UserBookReadEdge>>,
    Fragmentable {
  node: <T = UserBookReadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserBookReadSubscriptionPayload {
  mutation: MutationType;
  node: UserBookRead;
  updatedFields: String[];
  previousValues: UserBookReadPreviousValues;
}

export interface UserBookReadSubscriptionPayloadPromise
  extends Promise<UserBookReadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserBookReadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserBookReadPreviousValuesPromise>() => T;
}

export interface UserBookReadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserBookReadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserBookReadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserBookReadPreviousValuesSubscription>() => T;
}

export interface BookAuthor {
  id: ID_Output;
  name: String;
}

export interface BookAuthorPromise extends Promise<BookAuthor>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookAuthorSubscription
  extends Promise<AsyncIterator<BookAuthor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  books: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookAuthorNullablePromise
  extends Promise<BookAuthor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookHashtagSubscriptionPayload {
  mutation: MutationType;
  node: BookHashtag;
  updatedFields: String[];
  previousValues: BookHashtagPreviousValues;
}

export interface BookHashtagSubscriptionPayloadPromise
  extends Promise<BookHashtagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookHashtagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookHashtagPreviousValuesPromise>() => T;
}

export interface BookHashtagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookHashtagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookHashtagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookHashtagPreviousValuesSubscription>() => T;
}

export interface BookHashtagConnection {
  pageInfo: PageInfo;
  edges: BookHashtagEdge[];
}

export interface BookHashtagConnectionPromise
  extends Promise<BookHashtagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookHashtagEdge>>() => T;
  aggregate: <T = AggregateBookHashtagPromise>() => T;
}

export interface BookHashtagConnectionSubscription
  extends Promise<AsyncIterator<BookHashtagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookHashtagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookHashtagSubscription>() => T;
}

export interface UserBookReadPreviousValues {
  id: ID_Output;
  dateCreated: DateTimeOutput;
  rating: Int;
  comment: String;
}

export interface UserBookReadPreviousValuesPromise
  extends Promise<UserBookReadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateCreated: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
  comment: () => Promise<String>;
}

export interface UserBookReadPreviousValuesSubscription
  extends Promise<AsyncIterator<UserBookReadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<Int>>;
  comment: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  dateCreated: DateTimeOutput;
  dateUpdated: DateTimeOutput;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dateCreated: () => Promise<DateTimeOutput>;
  dateUpdated: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  dateCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BookHashtagPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BookHashtagPreviousValuesPromise
  extends Promise<BookHashtagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BookHashtagPreviousValuesSubscription
  extends Promise<AsyncIterator<BookHashtagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserBookWantConnection {
  pageInfo: PageInfo;
  edges: UserBookWantEdge[];
}

export interface UserBookWantConnectionPromise
  extends Promise<UserBookWantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserBookWantEdge>>() => T;
  aggregate: <T = AggregateUserBookWantPromise>() => T;
}

export interface UserBookWantConnectionSubscription
  extends Promise<AsyncIterator<UserBookWantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserBookWantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserBookWantSubscription>() => T;
}

export interface BookCategoryEdge {
  node: BookCategory;
  cursor: String;
}

export interface BookCategoryEdgePromise
  extends Promise<BookCategoryEdge>,
    Fragmentable {
  node: <T = BookCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookCategoryEdgeSubscription
  extends Promise<AsyncIterator<BookCategoryEdge>>,
    Fragmentable {
  node: <T = BookCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookHashtag {
  count: Int;
}

export interface AggregateBookHashtagPromise
  extends Promise<AggregateBookHashtag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookHashtagSubscription
  extends Promise<AsyncIterator<AggregateBookHashtag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserBookWantSubscriptionPayload {
  mutation: MutationType;
  node: UserBookWant;
  updatedFields: String[];
  previousValues: UserBookWantPreviousValues;
}

export interface UserBookWantSubscriptionPayloadPromise
  extends Promise<UserBookWantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserBookWantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserBookWantPreviousValuesPromise>() => T;
}

export interface UserBookWantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserBookWantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserBookWantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserBookWantPreviousValuesSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Book",
    embedded: false
  },
  {
    name: "BookCategory",
    embedded: false
  },
  {
    name: "BookHashtag",
    embedded: false
  },
  {
    name: "BookAuthor",
    embedded: false
  },
  {
    name: "UserBookRead",
    embedded: false
  },
  {
    name: "UserBookWant",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://us1.prisma.sh/jinho-hyeon-0e5e36/iwillread/dev`
});
export const prisma = new Prisma();
